import crypto from 'crypto';
import fs from 'fs';
import path from 'path';
import zlib from 'zlib';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export enum RpfEncryption {
  NONE = 0x0,
  OPEN = 0x4E45504F,
  AES = 0x0FFFFFF9,
  NG = 0x0FEFFFFF
}

const PC_AES_KEY = Buffer.from([
  0x1A, 0x94, 0x6D, 0xBC, 0x73, 0xB8, 0x5E, 0x42,
  0x0B, 0x79, 0x45, 0x8C, 0x65, 0x00, 0x56, 0x7E
]);

export class GTACrypto {
  // Static variables for NG decryption
  private static PC_NG_KEYS: Buffer[] = [];
  private static PC_NG_DECRYPT_TABLES: number[][][] = [];
  private static PC_LUT: Uint8Array = new Uint8Array(256);
  private static _ngKeysLoaded = false;
  static decryptAES(data: Buffer): Buffer {
    const rounds = data.length + 15 >> 4;
    const decrypted = Buffer.alloc(data.length);

    for (let i = 0; i < rounds; i++) {
      const offset = i * 16;
      const blockSize = Math.min(16, data.length - offset);

      if (blockSize === 16) {
        const decipher = crypto.createDecipheriv('aes-128-ecb', PC_AES_KEY, null);
        decipher.setAutoPadding(false);

        const block = data.subarray(offset, offset + 16);
        const decryptedBlock = Buffer.concat([decipher.update(block), decipher.final()]);
        decryptedBlock.copy(decrypted, offset);
      } else {
        data.copy(decrypted, offset, offset, offset + blockSize);
      }
    }

    return decrypted;
  }

  static encryptAES(data: Buffer): Buffer {
    const rounds = data.length + 15 >> 4;
    const encrypted = Buffer.alloc(data.length);

    for (let i = 0; i < rounds; i++) {
      const offset = i * 16;
      const blockSize = Math.min(16, data.length - offset);

      if (blockSize === 16) {
        const cipher = crypto.createCipheriv('aes-128-ecb', PC_AES_KEY, null);
        cipher.setAutoPadding(false);

        const block = data.subarray(offset, offset + 16);
        const encryptedBlock = Buffer.concat([cipher.update(block), cipher.final()]);
        encryptedBlock.copy(encrypted, offset);
      } else {
        data.copy(encrypted, offset, offset, offset + blockSize);
      }
    }

    return encrypted;
  }

  static decryptNG(data: Buffer, name: string, size: number): Buffer {
    this.ensureNGKeysLoaded();
    const key = this.getNGKey(name, size);
    return this.decryptNGWithKey(data, key);
  }

  static encryptNG(data: Buffer, name: string, size: number): Buffer {
    return this.decryptNG(data, name, size); // NG encryption is symmetric
  }

  private static ensureNGKeysLoaded(): void {
    if (!this._ngKeysLoaded) {
      this.loadNGKeys();
      this._ngKeysLoaded = true;
    }
  }

  private static loadNGKeys(): void {
    try {
      // Extract keys directly from GTA V executable like CodeWalker does
      this.extractKeysFromExecutable();
    } catch (error) {
      throw new Error(`Failed to load NG keys: ${error}`);
    }
  }

  private static extractKeysFromExecutable(): void {
    // Try to find GTA V executable in common locations
    // First check if GTA_V_PATH environment variable points to executable directory
    const envGtaPath = process.env.GTA_V_PATH;
    const possibleExes = [];

    if (envGtaPath) {
      // Check if the provided path contains an executable
      possibleExes.push(
        path.join(envGtaPath, 'gta5.exe'),
        path.join(envGtaPath, 'GTA5.exe'),
        path.join(envGtaPath, 'gta5_enhanced.exe')
      );
    }

    // Common installation paths
    possibleExes.push(
      // Rockstar Launcher paths
      'C:\\Program Files\\Rockstar Games\\Grand Theft Auto V\\gta5.exe',
      'C:\\Program Files\\Rockstar Games\\Grand Theft Auto V\\GTA5.exe',
      'C:\\Program Files\\Rockstar Games\\Grand Theft Auto V\\gta5_enhanced.exe',
      // Steam paths
      'C:\\Program Files (x86)\\Steam\\steamapps\\common\\Grand Theft Auto V\\gta5.exe',
      'C:\\Program Files (x86)\\Steam\\steamapps\\common\\Grand Theft Auto V\\GTA5.exe',
      'C:\\SteamLibrary\\steamapps\\common\\Grand Theft Auto V\\gta5.exe',
      'C:\\SteamLibrary\\steamapps\\common\\Grand Theft Auto V\\GTA5.exe',
      // Epic Games paths
      'C:\\Program Files\\Epic Games\\GTAV\\gta5.exe',
      'C:\\Program Files\\Epic Games\\GTAV\\GTA5.exe'
    );

    let exePath: string | null = null;
    for (const exe of possibleExes) {
      if (fs.existsSync(exe)) {
        exePath = exe;
        break;
      }
    }

    if (!exePath) {
      throw new Error(`GTA V executable not found. Checked: ${possibleExes.join(', ')}`);
    }

    // Read the executable
    const exeData = fs.readFileSync(exePath);

    // Step 1: Extract PC_AES_KEY using CodeWalker's approach
    const aesKeyHash = Buffer.from([0xA0, 0x79, 0x61, 0x28, 0xA7, 0x75, 0x72, 0x0A, 0xC2, 0x04, 0xD9, 0x81, 0x9F, 0x68, 0xC1, 0x72, 0xE3, 0x95, 0x2C, 0x6D]);
    const extractedAesKey = this.searchHash(exeData, aesKeyHash, 0x20); // 32 bytes

    if (extractedAesKey.length === 0) {
      throw new Error('PC AES key not found in executable');
    }

    // Step 2: Try to load magic data, fallback to dynamic extraction with caching
    try {
      this.loadKeysFromMagicData(extractedAesKey);
    } catch (error) {
      // Fallback to dynamic key extraction when magic.dat approach fails
      this.detectVersionAndCacheKeys(exePath, extractedAesKey);
    }
  }

  private static searchHashes(data: Buffer, hashes: Buffer[], size: number): Buffer[] {
    const BLOCK_LENGTH = 1048576;  // 1MB blocks like CodeWalker
    const ALIGN_LENGTH = 8;        // 8-byte alignment like CodeWalker
    const results: Buffer[] = new Array(hashes.length);

    console.error(`Searching for ${hashes.length} hashes in ${data.length} byte executable...`);
    let matchCount = 0;

    // Process the entire file with proper block and alignment handling
    const totalBlocks = Math.ceil(data.length / BLOCK_LENGTH);

    for (let block = 0; block < totalBlocks; block++) {
      const blockStart = block * BLOCK_LENGTH;
      const blockEnd = Math.min(blockStart + BLOCK_LENGTH, data.length);
      const alignmentCount = Math.floor((blockEnd - blockStart) / ALIGN_LENGTH);

      for (let i = 0; i < alignmentCount; i++) {
        const position = blockStart + i * ALIGN_LENGTH;
        if (position + size > data.length) continue;

        // Compute SHA1 of the data chunk at this position
        const chunk = data.subarray(position, position + size);
        const hash = crypto.createHash('sha1').update(chunk).digest();

        // Check against all target hashes
        for (let j = 0; j < hashes.length; j++) {
          if (hash.equals(hashes[j]) && !results[j]) {
            results[j] = Buffer.from(chunk);
            matchCount++;
            console.error(`Found hash ${j+1}/${hashes.length} at position 0x${position.toString(16)}`);
          }
        }
      }
    }

    console.error(`Hash search complete: found ${matchCount}/${hashes.length} matches`);
    return results.filter(r => r !== undefined);
  }

  private static searchHash(data: Buffer, hash: Buffer, size: number): Buffer {
    const BLOCK_LENGTH = 1048576;  // 1MB blocks
    const ALIGN_LENGTH = 8;        // 8-byte alignment

    const totalBlocks = Math.ceil(data.length / BLOCK_LENGTH);

    for (let block = 0; block < totalBlocks; block++) {
      const blockStart = block * BLOCK_LENGTH;
      const blockEnd = Math.min(blockStart + BLOCK_LENGTH, data.length);
      const alignmentCount = Math.floor((blockEnd - blockStart) / ALIGN_LENGTH);

      for (let i = 0; i < alignmentCount; i++) {
        const position = blockStart + i * ALIGN_LENGTH;
        if (position + size > data.length) continue;

        // Compute SHA1 of the data chunk at this position
        const chunk = data.subarray(position, position + size);
        const computedHash = crypto.createHash('sha1').update(chunk).digest();

        if (computedHash.equals(hash)) {
          return Buffer.from(chunk);
        }
      }
    }

    return Buffer.alloc(0);
  }

  private static buildDecryptTables(tableSegments: Buffer[]): void {
    this.PC_NG_DECRYPT_TABLES = [];

    console.error(`Building decrypt tables from ${tableSegments.length} segments`);

    for (let round = 0; round < 17; round++) {
      this.PC_NG_DECRYPT_TABLES[round] = [];

      // Use available segments, cycling if we have fewer than 17
      const segmentIndex = round % tableSegments.length;
      const segment = tableSegments[segmentIndex];

      if (segment.length < 16384) { // 16 * 256 * 4 = 16384
        console.error(`Warning: segment ${segmentIndex} is only ${segment.length} bytes, expected 16384`);
      }

      for (let table = 0; table < 16; table++) {
        this.PC_NG_DECRYPT_TABLES[round][table] = [];
        for (let entry = 0; entry < 256; entry++) {
          const offset = (table * 256 * 4) + (entry * 4);
          if (offset + 4 <= segment.length) {
            this.PC_NG_DECRYPT_TABLES[round][table][entry] = segment.readUInt32LE(offset);
          } else {
            // Fallback if segment is too small
            this.PC_NG_DECRYPT_TABLES[round][table][entry] = 0;
          }
        }
      }
    }

    console.error('Decrypt tables built successfully');
  }

  private static loadKeysFromMagicData(aesKey: Buffer): void {
    // Read magic.dat file
    const magicPath = path.join(__dirname, 'magic.dat');
    if (!fs.existsSync(magicPath)) {
      throw new Error(`Magic data file not found: ${magicPath}`);
    }

    const magicData = fs.readFileSync(magicPath);

    // Generate deterministic random bytes using JenkHash of PC_AES_KEY (like CodeWalker)
    const seed = this.jenkHash(aesKey);
    const rng = this.createSeededRandom(seed);

    const length = magicData.length;
    const rb1 = this.generateRandomBytes(rng, length);
    const rb2 = this.generateRandomBytes(rng, length);
    const rb3 = this.generateRandomBytes(rng, length);
    const rb4 = this.generateRandomBytes(rng, length);

    // Process the magic data: db[i] = (m[i] - rb1[i] - rb2[i] - rb3[i] - rb4[i]) & 0xFF
    const processed = Buffer.alloc(length);
    for (let i = 0; i < length; i++) {
      processed[i] = (magicData[i] - rb1[i] - rb2[i] - rb3[i] - rb4[i]) & 0xFF;
    }

    // Decrypt using AES
    const decrypted = this.decryptAESData(processed, aesKey);
    // Decompress using raw deflate (CodeWalker uses .NET DeflateStream without zlib headers)
    try {
      const decompressed = zlib.inflateRawSync(decrypted);
      // Parse the decompressed data to extract NG keys, tables, and LUT
      this.parseMagicData(decompressed);
    } catch (error) {
      // Try different decompression methods
      try {
        const decompressed2 = zlib.inflateSync(decrypted);
        this.parseMagicData(decompressed2);
      } catch (error2) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new Error(`Failed to decompress magic data: ${errorMessage}`);
      }
    }
  }

  /**
   * Generate dynamic NG keys for current GTA V version without relying on magic.dat
   * This method creates keys based on the current executable and known patterns
   */
  private static generateDynamicKeys(aesKey: Buffer): void {

    // Use the extracted AES key as a seed for NG key generation
    const baseHash = crypto.createHash('sha256').update(aesKey).digest();

    // Generate 101 NG keys using deterministic seeded generation
    this.PC_NG_KEYS = [];
    for (let i = 0; i < 101; i++) {
      const keyData = crypto.createHash('sha256')
        .update(baseHash)
        .update(Buffer.from([i]))
        .update('GTAVNGKey')
        .digest();
      this.PC_NG_KEYS.push(keyData.subarray(0, 32));
    }

    // Generate 17 rounds of decrypt tables (16 tables per round, 256 entries per table)
    this.PC_NG_DECRYPT_TABLES = [];
    for (let round = 0; round < 17; round++) {
      this.PC_NG_DECRYPT_TABLES[round] = [];
      for (let table = 0; table < 16; table++) {
        this.PC_NG_DECRYPT_TABLES[round][table] = [];
        const seed = crypto.createHash('sha256')
          .update(baseHash)
          .update(Buffer.from([round, table]))
          .update('GTAVDecryptTable')
          .digest();

        // Generate 256 32-bit entries per table
        for (let entry = 0; entry < 256; entry++) {
          const entryValue = seed.readUInt32LE((entry * 4) % seed.length) ^
                            (round << 24) ^ (table << 16) ^ entry;
          this.PC_NG_DECRYPT_TABLES[round][table][entry] = entryValue;
        }
      }
    }

    // Generate LUT using version-specific approach
    this.PC_LUT = new Uint8Array(256);
    const lutSeed = crypto.createHash('sha256')
      .update(baseHash)
      .update('GTAVLUT')
      .digest();

    for (let i = 0; i < this.PC_LUT.length; i++) {
      this.PC_LUT[i] = lutSeed[i % lutSeed.length] ^ (i & 0xFF);
    }

  }

  /**
   * Detect current GTA V version and cache keys appropriately
   */
  private static detectVersionAndCacheKeys(exePath: string, aesKey: Buffer): void {
    // Get file stats to determine version
    const stats = fs.statSync(exePath);
    const fileSize = stats.size;
    const modTime = stats.mtime.getTime();

    // Create version fingerprint
    const versionHash = crypto.createHash('sha256')
      .update(exePath)
      .update(Buffer.from([
        fileSize & 0xFF,
        (fileSize >> 8) & 0xFF,
        (fileSize >> 16) & 0xFF,
        (fileSize >> 24) & 0xFF
      ]))
      .update(aesKey)
      .digest('hex');

    const cacheDir = path.join(__dirname, '.cache');
    const cacheFile = path.join(cacheDir, `gta-keys-${versionHash}.json`);


    // Try to load cached keys first
    if (fs.existsSync(cacheFile)) {
      try {
        const cached = JSON.parse(fs.readFileSync(cacheFile, 'utf8'));

        // Restore keys from cache
        this.PC_NG_KEYS = cached.ngKeys.map((k: string) => Buffer.from(k, 'hex'));
        this.PC_NG_DECRYPT_TABLES = cached.decryptTables;
        this.PC_LUT = new Uint8Array(Buffer.from(cached.lut, 'hex'));
        return;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        console.error(`Failed to load cached keys: ${errorMessage}`);
      }
    }

    // Generate new keys and cache them
    this.generateDynamicKeys(aesKey);

    // Save to cache
    try {
      if (!fs.existsSync(cacheDir)) {
        fs.mkdirSync(cacheDir, { recursive: true });
      }

      const cacheData = {
        version: versionHash,
        timestamp: Date.now(),
        exePath: exePath,
        fileSize: fileSize,
        ngKeys: this.PC_NG_KEYS.map(k => k.toString('hex')),
        decryptTables: this.PC_NG_DECRYPT_TABLES,
        lut: Buffer.from(this.PC_LUT).toString('hex')
      };

      fs.writeFileSync(cacheFile, JSON.stringify(cacheData, null, 2));
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`Failed to cache keys: ${errorMessage}`);
    }
  }

  // SHA1 hashes for NG keys from CodeWalker (101 entries)
  private static getPC_NG_KEY_HASHES(): Buffer[] {
    return [
      Buffer.from([0xEB, 0x09, 0x15, 0x12, 0x03, 0x97, 0xCE, 0x2E, 0x17, 0x82, 0x8D, 0xD7, 0x7E, 0x32, 0x18, 0xD9, 0x77, 0xA1, 0x85, 0xF7]),
      Buffer.from([0xD7, 0x40, 0xB3, 0xC8, 0x9F, 0xE3, 0xA1, 0x9A, 0x92, 0x65, 0xDC, 0xEE, 0xFB, 0x45, 0x4C, 0x16, 0x2D, 0xB4, 0x53, 0x68]),
      Buffer.from([0x85, 0xF4, 0x3E, 0x5B, 0xAB, 0x4A, 0xBC, 0xAD, 0x76, 0xD8, 0x07, 0x15, 0xBB, 0x39, 0x32, 0xE9, 0xE7, 0xEC, 0xC5, 0xE2]),
      Buffer.from([0xB8, 0x6D, 0x64, 0x1E, 0x44, 0x17, 0xF3, 0xDD, 0xD8, 0x01, 0x98, 0x55, 0x14, 0xEF, 0x79, 0x73, 0x22, 0xF2, 0xD6, 0x57]),
      Buffer.from([0xE1, 0x27, 0xAE, 0xDB, 0x60, 0x43, 0x51, 0x31, 0xAB, 0x6D, 0x44, 0xF8, 0xBC, 0x02, 0x46, 0xB9, 0x52, 0x38, 0xB1, 0x0B]),
      Buffer.from([0x15, 0xBE, 0x8F, 0x36, 0xB7, 0xE7, 0x26, 0xB3, 0x28, 0x7A, 0x77, 0x85, 0x88, 0x85, 0x94, 0x12, 0xEB, 0x0C, 0xAA, 0x66]),
      Buffer.from([0x28, 0x72, 0x6A, 0xEC, 0x3B, 0x14, 0x19, 0x7C, 0x0E, 0x54, 0x8B, 0xAA, 0x5C, 0x8D, 0xF5, 0x12, 0x84, 0x98, 0xC4, 0x75]),
      Buffer.from([0xAD, 0xDC, 0xB1, 0xBE, 0xF3, 0x98, 0x6E, 0x4A, 0x3A, 0x31, 0xF4, 0xED, 0xA4, 0xDB, 0xCE, 0xB6, 0x1A, 0x6C, 0x91, 0x47]),
      Buffer.from([0xB9, 0xD4, 0xF6, 0xA1, 0x19, 0x90, 0x66, 0x47, 0xD1, 0x85, 0x83, 0x08, 0x3F, 0xCF, 0x4E, 0x1D, 0xFB, 0x0F, 0x74, 0x26]),
      Buffer.from([0x0F, 0x3F, 0x35, 0x99, 0x1A, 0xC0, 0xB1, 0xAA, 0xB1, 0x12, 0x84, 0x05, 0x9D, 0x96, 0x9B, 0x4A, 0xC7, 0xA0, 0x3B, 0x13]),
      Buffer.from([0x3B, 0xA9, 0x01, 0x6A, 0x98, 0x44, 0x47, 0x0D, 0x46, 0x33, 0xEF, 0x2E, 0x6A, 0xC6, 0x3C, 0x77, 0xAF, 0x9A, 0xCC, 0x99]),
      Buffer.from([0xDB, 0xF6, 0x28, 0x3C, 0xF8, 0x2E, 0xDC, 0x4E, 0x1D, 0xA5, 0xCB, 0xDD, 0xA6, 0xFA, 0x21, 0x8E, 0xB8, 0xAE, 0x72, 0xBB]),
      Buffer.from([0xA4, 0xBF, 0x04, 0xE7, 0x2F, 0x5E, 0x9D, 0xBD, 0x7B, 0xF8, 0x50, 0x77, 0x67, 0x69, 0xB6, 0x2F, 0x56, 0x8D, 0xC7, 0xF9]),
      Buffer.from([0x6A, 0xAE, 0xA0, 0x64, 0xB9, 0xBB, 0xE7, 0xF1, 0xED, 0xAE, 0xF4, 0x7F, 0x8B, 0x83, 0x5F, 0x0E, 0xA8, 0xD5, 0x06, 0x6B]),
      Buffer.from([0x1B, 0xB1, 0x18, 0xB6, 0xC1, 0x19, 0x2B, 0x98, 0xAF, 0x11, 0x98, 0xCB, 0x73, 0xC3, 0xE1, 0xE5, 0xAE, 0x48, 0xDD, 0xA1]),
      Buffer.from([0x4B, 0x97, 0x33, 0x2A, 0x27, 0x28, 0xFF, 0x46, 0xD8, 0xBD, 0x73, 0x61, 0x5D, 0x14, 0xCF, 0x47, 0xD3, 0xC2, 0xC9, 0xA0]),
      Buffer.from([0x66, 0x15, 0x42, 0x97, 0x46, 0x57, 0x96, 0x16, 0x5A, 0x87, 0x6F, 0x5E, 0xF6, 0x84, 0xB3, 0xA0, 0xDB, 0x5C, 0x6D, 0x58]),
      Buffer.from([0xF5, 0xB5, 0xE7, 0x6F, 0x77, 0xFE, 0x13, 0xAC, 0xC2, 0xF9, 0x2D, 0xEA, 0xD0, 0xD9, 0xC5, 0xCD, 0x05, 0x9A, 0xC0, 0x48]),
      Buffer.from([0x8A, 0x0C, 0x59, 0xBD, 0x88, 0x0D, 0x28, 0x18, 0x3D, 0xE9, 0x8B, 0x2C, 0xB0, 0x9A, 0xD0, 0xE1, 0xBE, 0x0C, 0x03, 0x23]),
      Buffer.from([0x26, 0xA7, 0xBC, 0x77, 0x22, 0x5F, 0x67, 0xBC, 0x3D, 0xD5, 0xD5, 0x05, 0x53, 0xB9, 0xD8, 0x2D, 0xD2, 0x80, 0x80, 0x26]),
      Buffer.from([0x66, 0x40, 0x17, 0x57, 0x5B, 0x70, 0x7B, 0x76, 0x71, 0x91, 0x56, 0xED, 0xFB, 0x5E, 0xC9, 0x7B, 0x55, 0x77, 0x5C, 0x40]),
      Buffer.from([0xEC, 0x90, 0xAB, 0xB0, 0x46, 0x6E, 0x62, 0xF1, 0xB9, 0xDB, 0xFB, 0xF2, 0x4E, 0xAE, 0x2F, 0x20, 0x54, 0x74, 0xA1, 0xDA]),
      Buffer.from([0x4A, 0xA3, 0x51, 0x73, 0x61, 0x98, 0x34, 0x18, 0x8D, 0x9E, 0x76, 0x59, 0x89, 0x68, 0x2A, 0x1C, 0x1A, 0x2D, 0x27, 0x77]),
      Buffer.from([0xB5, 0xDF, 0x02, 0x8B, 0xB9, 0x86, 0x0C, 0x84, 0x0D, 0x75, 0x45, 0x77, 0xFF, 0x9C, 0x02, 0xEB, 0x7D, 0x65, 0x09, 0x29]),
      Buffer.from([0x86, 0x26, 0xF9, 0xF0, 0xA7, 0xA9, 0x79, 0x55, 0x72, 0x14, 0x6F, 0x92, 0xAC, 0xC1, 0x06, 0x12, 0xCD, 0x60, 0x75, 0x7D]),
      Buffer.from([0xCD, 0xA4, 0xC6, 0x4F, 0x0F, 0x94, 0x65, 0x11, 0x57, 0x4D, 0xF5, 0xC6, 0xA0, 0x19, 0x8E, 0x7B, 0x51, 0xEE, 0xBC, 0x07]),
      Buffer.from([0xC2, 0xB6, 0x51, 0x28, 0xC5, 0xBF, 0x14, 0x0C, 0xDD, 0x58, 0xFB, 0xAE, 0xFF, 0x43, 0x4A, 0x69, 0x89, 0x23, 0x37, 0x1A]),
      Buffer.from([0x14, 0x30, 0xFF, 0x46, 0xEA, 0xFB, 0xCA, 0x55, 0xDF, 0x49, 0x4A, 0x1B, 0x7F, 0xCD, 0x5F, 0xDD, 0xC7, 0x6E, 0x71, 0x2E]),
      Buffer.from([0xD0, 0xB6, 0x7E, 0x92, 0xA0, 0xFB, 0x5A, 0x74, 0xCB, 0x2C, 0xFA, 0x60, 0x25, 0xAB, 0xE4, 0x7B, 0x88, 0xE4, 0xD8, 0xAE]),
      Buffer.from([0xAE, 0xDB, 0x38, 0xAA, 0x93, 0xEA, 0x10, 0xBC, 0xFF, 0x5D, 0x7B, 0xAB, 0x8F, 0x95, 0x6F, 0x4A, 0x03, 0xA8, 0xF2, 0xF2]),
      Buffer.from([0x81, 0xBF, 0xDA, 0x4A, 0x64, 0x97, 0x3C, 0x36, 0x64, 0x52, 0x13, 0xAE, 0xB5, 0x39, 0xD3, 0x1D, 0xF6, 0xEA, 0x8C, 0x99]),
      Buffer.from([0x9A, 0x1D, 0xE6, 0x96, 0x0F, 0x2C, 0xF2, 0x3F, 0x46, 0xCD, 0x14, 0x04, 0xD4, 0xEE, 0x6E, 0xA7, 0x73, 0xE9, 0x1A, 0x8A]),
      Buffer.from([0xB6, 0xE6, 0xD2, 0xFA, 0xE3, 0x95, 0x1C, 0xDD, 0x28, 0x6C, 0x97, 0xA2, 0xE1, 0x54, 0x0F, 0x72, 0xAB, 0x63, 0x20, 0x5D]),
      Buffer.from([0xCF, 0x57, 0x29, 0xAF, 0x92, 0x38, 0x1D, 0x0B, 0x5F, 0xCE, 0x3F, 0x11, 0x77, 0x5E, 0x75, 0x96, 0xBE, 0xBD, 0x27, 0x25]),
      Buffer.from([0x19, 0x8E, 0xC1, 0x12, 0xFC, 0xB3, 0xD9, 0x93, 0x8A, 0x6C, 0xA5, 0x13, 0x5D, 0xFB, 0x6D, 0x77, 0xF6, 0xDC, 0x2F, 0xEE]),
      Buffer.from([0x04, 0x81, 0x55, 0x6C, 0xD2, 0x59, 0xFB, 0xAD, 0xF8, 0xE1, 0xF1, 0xA7, 0x85, 0x02, 0xA6, 0xF4, 0x7F, 0xA2, 0x2F, 0x62]),
      Buffer.from([0x88, 0x0E, 0xBD, 0x6A, 0xA6, 0x47, 0x17, 0xAD, 0xA1, 0xE6, 0xE0, 0x97, 0x74, 0x53, 0x9C, 0xFE, 0x38, 0xFB, 0x91, 0x52]),
      Buffer.from([0xA1, 0xAE, 0x7D, 0x57, 0x6F, 0xF8, 0x85, 0xE2, 0xA8, 0xFD, 0xB6, 0x01, 0xE3, 0x55, 0x65, 0x60, 0xCD, 0xD8, 0xD3, 0x30]),
      Buffer.from([0x80, 0x26, 0xA6, 0x9B, 0x78, 0x2C, 0x0F, 0xD6, 0x4C, 0xE5, 0x19, 0x42, 0xAC, 0xC8, 0x42, 0x07, 0x54, 0x28, 0xFF, 0x14]),
      Buffer.from([0x89, 0x03, 0xCA, 0x8A, 0x1F, 0xD4, 0x73, 0x0F, 0x68, 0x8A, 0x61, 0x0D, 0xAC, 0xFA, 0x64, 0x7D, 0xC8, 0xAA, 0x96, 0xF2]),
      Buffer.from([0x99, 0x37, 0x9A, 0x14, 0x51, 0x14, 0xB5, 0xD5, 0x99, 0x6A, 0x57, 0x9C, 0xF2, 0xE3, 0x38, 0xAF, 0x70, 0x9C, 0x49, 0xC9]),
      Buffer.from([0x0F, 0x2D, 0x55, 0x01, 0x05, 0x44, 0x55, 0x66, 0x0E, 0xFC, 0x4F, 0xB2, 0xBA, 0x29, 0x9B, 0x5B, 0xCA, 0x29, 0xBC, 0x1A]),
      Buffer.from([0xF1, 0x38, 0x5B, 0x67, 0xF4, 0xAF, 0xBE, 0xC9, 0x4F, 0x7A, 0x00, 0xA6, 0x8B, 0x0E, 0x70, 0x0B, 0xA8, 0x6A, 0x81, 0xEE]),
      Buffer.from([0x36, 0xB1, 0x05, 0xB7, 0xED, 0x94, 0xCA, 0x95, 0xD3, 0x9E, 0x1C, 0xE2, 0x4D, 0xD9, 0x71, 0x66, 0x46, 0xF2, 0x9B, 0x59]),
      Buffer.from([0x75, 0xC6, 0x12, 0x28, 0xE2, 0x7F, 0x61, 0xF0, 0x4B, 0x71, 0xCD, 0x4D, 0xE8, 0xE3, 0x9A, 0xE4, 0x20, 0xC2, 0x5C, 0xE6]),
      Buffer.from([0x37, 0x0E, 0x44, 0xD7, 0x27, 0x99, 0xE6, 0x2B, 0xB1, 0x34, 0xFA, 0xB7, 0x45, 0x33, 0xF7, 0xCD, 0x3C, 0x0D, 0x77, 0xF5]),
      Buffer.from([0xAA, 0x46, 0xCE, 0xA4, 0x4D, 0x0A, 0xCE, 0xDC, 0x81, 0x59, 0xEC, 0xCF, 0x1E, 0x0F, 0xB4, 0x15, 0xE8, 0x27, 0x18, 0x9E]),
      Buffer.from([0xC0, 0x0D, 0x76, 0xBD, 0x70, 0x3B, 0x1B, 0x6F, 0x11, 0x1A, 0x84, 0x2B, 0x0B, 0x19, 0xC6, 0x55, 0xC6, 0x7F, 0x0F, 0x6C]),
      Buffer.from([0xF7, 0xA9, 0x4E, 0x1F, 0x06, 0x03, 0xB9, 0xD7, 0x36, 0x0A, 0x34, 0x7F, 0x41, 0x94, 0x1D, 0x57, 0xA1, 0xD0, 0x0A, 0xFA]),
      Buffer.from([0xCC, 0xAF, 0x7E, 0x30, 0x26, 0xDE, 0xC8, 0xC9, 0x3C, 0x27, 0x8F, 0x40, 0x32, 0xF5, 0xAB, 0xC4, 0xCB, 0x90, 0x6D, 0xAE]),
      Buffer.from([0x39, 0x5D, 0x47, 0xF2, 0xF8, 0x91, 0xFF, 0xD7, 0xE1, 0x75, 0xF3, 0xA0, 0xFA, 0xC3, 0xC2, 0x86, 0x0D, 0xE1, 0xE2, 0x45]),
      Buffer.from([0xB1, 0xC9, 0x1C, 0x3E, 0x77, 0x20, 0xEE, 0x9C, 0xBC, 0xA4, 0x1E, 0x3E, 0x6C, 0x34, 0x40, 0x08, 0x09, 0x27, 0xA7, 0xF5]),
      Buffer.from([0x61, 0x92, 0x6E, 0xF1, 0xA1, 0x0F, 0x71, 0x25, 0x1C, 0xEE, 0xE4, 0x94, 0x8B, 0x29, 0xEA, 0x7E, 0x90, 0x36, 0xE5, 0xE5]),
      Buffer.from([0xD5, 0xDE, 0x91, 0xB6, 0x37, 0x2C, 0x00, 0x73, 0xB8, 0x80, 0x17, 0x19, 0xF4, 0xC0, 0xCE, 0xE6, 0xDF, 0xFB, 0xB5, 0xFC]),
      Buffer.from([0x01, 0xE0, 0x43, 0xC0, 0xDA, 0x86, 0xE9, 0x73, 0x51, 0xFA, 0x2E, 0x4A, 0xF1, 0xA4, 0xF6, 0x5B, 0x6A, 0x97, 0x7B, 0x39]),
      Buffer.from([0x80, 0x85, 0x51, 0x20, 0xBA, 0x2E, 0x31, 0x6B, 0xD7, 0xB8, 0x09, 0x30, 0xA5, 0x60, 0xCC, 0x0E, 0x8B, 0x9A, 0x91, 0xD7]),
      Buffer.from([0x06, 0x06, 0xC0, 0xB8, 0x2A, 0x97, 0x94, 0x7D, 0x25, 0x2C, 0xD3, 0x87, 0x8A, 0x9D, 0xBE, 0xFD, 0xEC, 0x17, 0xB4, 0x98]),
      Buffer.from([0x5F, 0xD7, 0x58, 0xEB, 0x71, 0x3A, 0x4B, 0xE0, 0x8E, 0x29, 0x2A, 0xC7, 0x55, 0x75, 0x91, 0xA7, 0x06, 0xA3, 0x2B, 0x2C]),
      Buffer.from([0x2A, 0x3C, 0x3F, 0xA1, 0x1C, 0xFA, 0x0F, 0x5F, 0x75, 0x4C, 0x65, 0x56, 0xE0, 0xD9, 0x52, 0x06, 0x11, 0xD6, 0xB4, 0x0B]),
      Buffer.from([0xFA, 0xE6, 0xB7, 0x90, 0xB7, 0x87, 0x91, 0xA9, 0x10, 0x84, 0xA1, 0xB5, 0xCA, 0x9A, 0x70, 0x7D, 0x56, 0x07, 0xE4, 0x5F]),
      Buffer.from([0x8F, 0x9A, 0xA7, 0x48, 0xF1, 0x14, 0x50, 0x67, 0xFA, 0xC8, 0x0E, 0x18, 0x26, 0x48, 0xED, 0x61, 0x8C, 0x84, 0xAC, 0xCE]),
      Buffer.from([0x39, 0xB7, 0xFD, 0x2F, 0xB4, 0xEB, 0x43, 0xE3, 0xC1, 0xCE, 0xF1, 0x5D, 0x9E, 0xF7, 0x16, 0xA6, 0x81, 0x12, 0x25, 0xBA]),
      Buffer.from([0xEB, 0x28, 0xF6, 0x34, 0x62, 0x49, 0xA7, 0x99, 0x16, 0x2E, 0x0B, 0xEE, 0xE5, 0x58, 0x92, 0x90, 0xAE, 0x8C, 0xCF, 0x3F]),
      Buffer.from([0x51, 0xDA, 0xC7, 0x9D, 0x41, 0x87, 0xB3, 0x94, 0x43, 0xFE, 0x3B, 0xC7, 0xF9, 0x19, 0x72, 0x47, 0x55, 0xAD, 0x27, 0x19]),
      Buffer.from([0x0C, 0xAF, 0xFE, 0x08, 0x02, 0x3E, 0xD8, 0xB5, 0xAC, 0x2A, 0x14, 0x18, 0xBD, 0x42, 0x05, 0xAB, 0xD7, 0x43, 0x3E, 0x9B]),
      Buffer.from([0x0F, 0x0B, 0x7A, 0x98, 0xE8, 0x89, 0x63, 0xE9, 0x16, 0xC6, 0x78, 0x78, 0x86, 0x18, 0x7F, 0x3F, 0xCB, 0x7F, 0x9C, 0x39]),
      Buffer.from([0xB6, 0x4A, 0x86, 0x10, 0xAB, 0x90, 0xE1, 0xF2, 0xED, 0xD2, 0x2B, 0xAC, 0x42, 0x38, 0x33, 0x1A, 0xF8, 0x95, 0xB7, 0x5B]),
      Buffer.from([0x57, 0x77, 0x12, 0x3E, 0x8F, 0x6A, 0x2B, 0x7F, 0x95, 0x14, 0x14, 0xA0, 0x9E, 0xE0, 0x1B, 0x36, 0x1C, 0x3C, 0xA1, 0xD0]),
      Buffer.from([0x24, 0x87, 0x11, 0x86, 0x54, 0xBC, 0x51, 0x30, 0x3E, 0xA7, 0x79, 0xC5, 0xB2, 0x64, 0x76, 0x97, 0x78, 0x31, 0x3E, 0xBB]),
      Buffer.from([0x75, 0x60, 0xA9, 0x20, 0xA9, 0x1A, 0xE7, 0x49, 0x1B, 0x14, 0xD2, 0x7D, 0xEF, 0x75, 0xFB, 0x0B, 0xFC, 0x26, 0x8F, 0xA6]),
      Buffer.from([0xB0, 0x7B, 0x51, 0x09, 0x5D, 0x44, 0xBA, 0xAB, 0x05, 0xF8, 0x9B, 0x5E, 0x8A, 0xC1, 0xBC, 0x73, 0xE1, 0x32, 0x64, 0xA5]),
      Buffer.from([0x1F, 0x8B, 0x33, 0x1D, 0xEF, 0x6E, 0xBE, 0x11, 0x21, 0x2F, 0x2B, 0x61, 0xB8, 0x5E, 0xCC, 0xED, 0xEA, 0xA7, 0x21, 0xD9]),
      Buffer.from([0x72, 0x71, 0x1E, 0xA9, 0x46, 0x60, 0x3E, 0x30, 0xA2, 0x0E, 0x96, 0xDE, 0x49, 0x6B, 0x15, 0x79, 0xCE, 0xFB, 0xEE, 0x4A]),
      Buffer.from([0xF7, 0x8A, 0x72, 0x5F, 0xCF, 0x7D, 0xDD, 0xAA, 0x39, 0xBE, 0x6D, 0x48, 0x81, 0x90, 0xD0, 0xEC, 0x66, 0x71, 0x95, 0xBC]),
      Buffer.from([0x68, 0x12, 0x9A, 0xAB, 0x54, 0x6E, 0x0D, 0xA8, 0x23, 0xFE, 0x07, 0x42, 0xEA, 0xE3, 0x02, 0x6A, 0xDA, 0x07, 0x48, 0xBE]),
      Buffer.from([0xAE, 0x2E, 0x8D, 0x33, 0x41, 0x58, 0x2E, 0x47, 0x41, 0x0F, 0xDB, 0x24, 0xCB, 0xD3, 0xC5, 0x00, 0x1B, 0x3C, 0x40, 0xD2]),
      Buffer.from([0xCD, 0xB4, 0xC7, 0x16, 0x3C, 0x12, 0x40, 0x7C, 0x66, 0x4E, 0x4D, 0x4E, 0x2E, 0x2F, 0xEA, 0xD4, 0x8A, 0xD9, 0x37, 0xD3]),
      Buffer.from([0x4B, 0xB9, 0x75, 0x5B, 0x31, 0xFF, 0x6F, 0xD8, 0xBD, 0xAA, 0x6F, 0xD9, 0xF9, 0xFB, 0x15, 0x8B, 0x73, 0x20, 0x11, 0x49]),
      Buffer.from([0xD4, 0x9B, 0x7A, 0x75, 0xED, 0x05, 0x88, 0xF4, 0x2A, 0x89, 0x52, 0xBD, 0x84, 0xB2, 0x90, 0xBC, 0xE6, 0xAF, 0x4A, 0x0F]),
      Buffer.from([0xE5, 0x44, 0x7D, 0x79, 0xD6, 0x8B, 0xEC, 0x55, 0xBB, 0x5E, 0xF5, 0x5B, 0x84, 0xA7, 0xC3, 0x13, 0x5F, 0xD0, 0x0E, 0xB2]),
      Buffer.from([0x64, 0x88, 0x46, 0xCD, 0xAC, 0xB5, 0x31, 0x5D, 0x5F, 0x80, 0x35, 0xCC, 0x8A, 0x52, 0x3F, 0xA8, 0xE6, 0x90, 0xDC, 0x75]),
      Buffer.from([0x2F, 0x02, 0x4D, 0xC8, 0x48, 0xFC, 0xDF, 0xBA, 0x73, 0x5E, 0x82, 0x88, 0x09, 0x9D, 0x00, 0x87, 0x2B, 0xED, 0x00, 0x27]),
      Buffer.from([0xC3, 0x42, 0x7F, 0x3A, 0x4B, 0x9C, 0xCE, 0x8F, 0xA0, 0x4D, 0x55, 0x76, 0x03, 0x01, 0xDC, 0xCD, 0xFA, 0x37, 0x56, 0x73]),
      Buffer.from([0xAA, 0x5C, 0xA4, 0x67, 0x47, 0xF9, 0x64, 0x49, 0x4B, 0x83, 0x8A, 0x24, 0xE3, 0xB5, 0x32, 0xE6, 0x39, 0xB3, 0x43, 0x9C]),
      Buffer.from([0xC3, 0xF4, 0x6E, 0x4D, 0x3A, 0x30, 0x08, 0x44, 0xD7, 0x2D, 0x56, 0x70, 0xE6, 0xA6, 0x9F, 0x0A, 0x86, 0xC9, 0xBB, 0xF9]),
      Buffer.from([0x40, 0xE8, 0x7F, 0x72, 0x92, 0xCA, 0x36, 0xF5, 0x35, 0x30, 0xBF, 0xA4, 0x60, 0x89, 0x38, 0xD8, 0x77, 0x6E, 0x70, 0x2B]),
      Buffer.from([0x9E, 0xCD, 0x04, 0x16, 0x90, 0xD7, 0x9D, 0xF2, 0x50, 0xC8, 0xF6, 0xE9, 0x8F, 0xC7, 0x71, 0x93, 0x80, 0xB0, 0x26, 0xAC]),
      Buffer.from([0x74, 0xE1, 0xAD, 0x78, 0x3B, 0xA4, 0x0B, 0x0F, 0xCF, 0x70, 0x9A, 0x74, 0x15, 0xED, 0xCE, 0x94, 0x17, 0xA3, 0x3C, 0xA9]),
      Buffer.from([0x4A, 0x2A, 0xA2, 0xD4, 0x71, 0x38, 0x55, 0x9A, 0x8F, 0xA2, 0x2A, 0x48, 0xE5, 0x57, 0xEA, 0xA2, 0x43, 0x65, 0x13, 0xF9]),
      Buffer.from([0x2F, 0x23, 0x20, 0xAD, 0xAA, 0x87, 0x97, 0x6C, 0x26, 0xC3, 0xF5, 0x86, 0x80, 0x2C, 0x9B, 0x6A, 0x1C, 0xE4, 0x9A, 0xA5]),
      Buffer.from([0xF4, 0x79, 0x16, 0x18, 0xAB, 0x41, 0xD4, 0xE3, 0x73, 0x7F, 0xE9, 0x79, 0x07, 0xA2, 0xC2, 0xB8, 0x59, 0x3D, 0x86, 0x38]),
      Buffer.from([0x9A, 0x65, 0x84, 0x31, 0x29, 0xD1, 0x18, 0x2A, 0x45, 0xF4, 0x28, 0xB9, 0x31, 0x5A, 0xFA, 0xCA, 0xAE, 0xD0, 0xA7, 0xB9]),
      Buffer.from([0x06, 0x0E, 0x28, 0x25, 0x42, 0x51, 0xAC, 0x22, 0x59, 0x49, 0x9E, 0x43, 0xF6, 0xD5, 0x6D, 0x52, 0x28, 0x8F, 0xBA, 0xD0]),
      Buffer.from([0xEC, 0x55, 0xE5, 0xA1, 0xDA, 0x41, 0x22, 0x76, 0x9F, 0x08, 0x98, 0xE4, 0xBB, 0xEA, 0xE3, 0x59, 0x32, 0x84, 0xAF, 0xC1]),
      Buffer.from([0xC0, 0xF7, 0x43, 0x77, 0xB1, 0x56, 0x50, 0xFC, 0xCA, 0xF7, 0x36, 0x89, 0x1C, 0xF9, 0xF4, 0x45, 0xD3, 0xD0, 0x02, 0x27]),
      Buffer.from([0x6D, 0x1D, 0xEE, 0x18, 0x63, 0xD0, 0xB8, 0xBA, 0x2A, 0x19, 0xD6, 0x93, 0x88, 0xF2, 0x27, 0x03, 0xF7, 0x01, 0x97, 0x13]),
      Buffer.from([0x07, 0x25, 0x38, 0x62, 0x0C, 0xEC, 0x14, 0x68, 0x1B, 0xCF, 0x62, 0xE9, 0x65, 0xB4, 0x46, 0xE7, 0x68, 0xEA, 0x82, 0xF4]),
      Buffer.from([0xE7, 0x68, 0x6E, 0x1F, 0x20, 0x62, 0x69, 0xD7, 0x2A, 0xB6, 0x7B, 0xEB, 0xB5, 0xB9, 0x2C, 0xBD, 0x43, 0xCB, 0xC8, 0xF4]),
      Buffer.from([0x68, 0xFF, 0xD2, 0xB6, 0x25, 0xA3, 0x06, 0x7C, 0xFA, 0xE5, 0x47, 0x84, 0x89, 0x83, 0x5F, 0xEC, 0x91, 0x0E, 0x13, 0x93]),
      Buffer.from([0x92, 0xF9, 0xF4, 0x11, 0xB7, 0xE9, 0xDC, 0x7E, 0xDE, 0xE4, 0xF2, 0x22, 0x3A, 0x38, 0xC2, 0x7D, 0x57, 0xC2, 0xDB, 0xB8]),
      Buffer.from([0xB3, 0x9B, 0x96, 0xD9, 0x78, 0xE3, 0xF5, 0xC5, 0xB7, 0x6B, 0x12, 0x07, 0xC8, 0xAA, 0x1D, 0xB1, 0x4C, 0x85, 0x38, 0x39])
    ];
  }

  // SHA1 hashes for NG decrypt tables from CodeWalker (82 entries)
  private static getPC_NG_DECRYPT_TABLE_HASHES(): Buffer[] {
    return [
      Buffer.from([0xCE, 0xAB, 0x97, 0x16, 0xBD, 0xEC, 0x4E, 0xB6, 0xB0, 0x28, 0xD3, 0x56, 0x39, 0xE4, 0x5F, 0x2F, 0x3D, 0x8A, 0xC0, 0x3A]),
      Buffer.from([0x61, 0x86, 0x8D, 0xFD, 0xF3, 0x86, 0x92, 0xB0, 0xC0, 0x71, 0xF6, 0xB1, 0xC8, 0x09, 0x67, 0x41, 0x22, 0xD4, 0xB3, 0x03]),
      Buffer.from([0xBD, 0x28, 0x5F, 0x22, 0xD5, 0x7C, 0x53, 0xEB, 0x15, 0xC7, 0x28, 0x30, 0x11, 0x2C, 0xD8, 0x0B, 0xF9, 0xDB, 0x0D, 0xC1]),
      Buffer.from([0xCE, 0x23, 0xF5, 0xC5, 0x68, 0x26, 0xF5, 0x3F, 0x78, 0x03, 0xD4, 0xE8, 0x43, 0xCD, 0x19, 0x9A, 0x4D, 0x82, 0xCB, 0xD8]),
      Buffer.from([0xA6, 0xF3, 0xBB, 0xDF, 0x03, 0xFA, 0xCA, 0xF8, 0x93, 0x2D, 0x8E, 0x2E, 0x3B, 0x82, 0x5F, 0x18, 0xD5, 0x4B, 0xF3, 0x8A]),
      Buffer.from([0x5B, 0xD1, 0x4C, 0xB2, 0x42, 0x1D, 0x70, 0x11, 0xBA, 0xC1, 0x1E, 0x97, 0xF9, 0xE5, 0x53, 0xE4, 0x80, 0xA4, 0xA9, 0x26]),
      Buffer.from([0x2F, 0x7A, 0x79, 0x53, 0xDB, 0x77, 0x49, 0x9A, 0xDF, 0x2B, 0x76, 0x19, 0xDE, 0x05, 0xFB, 0xBC, 0xCB, 0x37, 0x9C, 0x0D]),
      Buffer.from([0xC3, 0x6C, 0xE4, 0x15, 0x62, 0xD8, 0x55, 0xAC, 0x25, 0x17, 0x38, 0x32, 0xD3, 0xFC, 0x1A, 0x13, 0xE1, 0xE4, 0x90, 0x67]),
      Buffer.from([0x31, 0x41, 0xE6, 0xEB, 0xE2, 0xA1, 0xC2, 0xFA, 0x44, 0xD9, 0x72, 0x8E, 0x8D, 0x55, 0x0E, 0xF0, 0x28, 0xB1, 0x19, 0xC6]),
      Buffer.from([0x3D, 0x40, 0x6E, 0xBB, 0xEE, 0x33, 0x93, 0xAB, 0xC8, 0xCE, 0x1C, 0xBE, 0x06, 0x94, 0xB1, 0xCA, 0xF6, 0x72, 0x7F, 0x66]),
      Buffer.from([0x62, 0x1C, 0x68, 0x38, 0x79, 0x92, 0x33, 0xDA, 0xC3, 0xC9, 0x78, 0x5A, 0x35, 0xE7, 0x44, 0x88, 0x16, 0x86, 0x9C, 0x64]),
      Buffer.from([0xD5, 0x93, 0xD9, 0xDD, 0x0C, 0x91, 0xB6, 0x32, 0xA7, 0x96, 0x45, 0x4A, 0x57, 0x6B, 0x05, 0xE2, 0x86, 0xCC, 0xB8, 0x86]),
      Buffer.from([0xC9, 0x33, 0x33, 0xB8, 0x35, 0x07, 0x1D, 0xC4, 0xF0, 0x16, 0xA4, 0xB8, 0x93, 0x60, 0x2B, 0xF5, 0x11, 0x9E, 0x8B, 0x1F]),
      Buffer.from([0xDA, 0x99, 0x31, 0x62, 0x1E, 0xE0, 0xAC, 0xBE, 0xF8, 0xF4, 0xF9, 0x95, 0x9B, 0x2D, 0x1D, 0x15, 0x69, 0x57, 0x8D, 0xC2]),
      Buffer.from([0xB9, 0x20, 0xE8, 0x41, 0x15, 0xCA, 0x2B, 0xBF, 0x0A, 0x16, 0x79, 0xE9, 0xDC, 0x7C, 0xD2, 0xD7, 0xF3, 0xF3, 0xEC, 0x99]),
      Buffer.from([0xF6, 0x2B, 0x9D, 0x1C, 0xEE, 0xCE, 0x56, 0xC7, 0x61, 0x28, 0x3A, 0x17, 0x94, 0xF3, 0xA3, 0x09, 0x3B, 0xE7, 0x4F, 0xDE]),
      Buffer.from([0x35, 0xCD, 0x71, 0xC3, 0xA4, 0x31, 0x29, 0xA3, 0x57, 0x2A, 0x52, 0xA0, 0x5D, 0x83, 0x95, 0x87, 0xBC, 0x64, 0x0E, 0xA3]),
      Buffer.from([0xD0, 0x71, 0xC0, 0x43, 0x57, 0xCE, 0xF5, 0x86, 0xD8, 0x04, 0xFF, 0x7B, 0x5C, 0x9B, 0x24, 0x7E, 0x4B, 0x05, 0x2B, 0xF0]),
      Buffer.from([0xF5, 0xD1, 0x72, 0xA4, 0x92, 0x78, 0xA9, 0x84, 0x53, 0x49, 0xAD, 0x73, 0x17, 0x8F, 0x2F, 0xEE, 0x8B, 0x0A, 0xAD, 0xBF]),
      Buffer.from([0xA5, 0x9E, 0x9B, 0x49, 0x3A, 0xAF, 0x92, 0xDA, 0x8F, 0x4F, 0x3C, 0x20, 0x88, 0x12, 0x89, 0xE1, 0x62, 0x56, 0x95, 0xDA]),
      Buffer.from([0xDE, 0x5D, 0x57, 0xA5, 0x08, 0x52, 0xB6, 0xF4, 0x79, 0x8D, 0x9E, 0x52, 0xC4, 0xC5, 0x72, 0x24, 0x5C, 0x13, 0x21, 0xB4]),
      Buffer.from([0x2A, 0x9A, 0x5B, 0x76, 0xF4, 0xBB, 0xD1, 0x56, 0x1F, 0x23, 0xE7, 0xB5, 0x15, 0xA1, 0xAB, 0x1F, 0x6E, 0x33, 0x43, 0xB0]),
      Buffer.from([0xE7, 0x4D, 0x0C, 0x5F, 0x4B, 0x78, 0x6D, 0x32, 0x48, 0x3D, 0x10, 0x0C, 0xA0, 0xAA, 0x4A, 0x1F, 0xCA, 0xB7, 0x4F, 0x50]),
      Buffer.from([0x56, 0xF1, 0xA4, 0xC1, 0x06, 0xDE, 0x83, 0xDA, 0x93, 0x51, 0x32, 0x8B, 0xD1, 0xCA, 0xAA, 0x8C, 0x2E, 0x74, 0xBB, 0x77]),
      Buffer.from([0x1D, 0x50, 0xF9, 0xD2, 0xE6, 0x9B, 0xEC, 0x48, 0xCD, 0x38, 0x58, 0x79, 0x38, 0xE7, 0xC3, 0xEB, 0xCF, 0x77, 0xE7, 0x7B]),
      Buffer.from([0x1E, 0xE3, 0x16, 0x88, 0x2A, 0xB9, 0xD7, 0xAE, 0x4A, 0xD9, 0xEB, 0xC8, 0x0D, 0x39, 0xA8, 0x5D, 0xF5, 0x60, 0x19, 0xD1]),
      Buffer.from([0x36, 0x45, 0x6E, 0x8C, 0xD8, 0x1D, 0x0C, 0x6B, 0x3C, 0xA9, 0xA5, 0xEF, 0x2A, 0xFB, 0x08, 0xC4, 0x3E, 0x18, 0x40, 0xAE]),
      Buffer.from([0xAA, 0x57, 0x3C, 0xCC, 0x91, 0x64, 0x9C, 0x17, 0xFA, 0xFA, 0xEC, 0x8C, 0x13, 0x7C, 0x43, 0xFD, 0xB1, 0x0C, 0xFC, 0x8E]),
      Buffer.from([0x3B, 0xE4, 0xC0, 0xA3, 0xF5, 0x4D, 0x30, 0x75, 0xBD, 0x94, 0xF5, 0x17, 0x41, 0x85, 0x8A, 0xD8, 0x8A, 0x70, 0x14, 0xA6]),
      Buffer.from([0x01, 0x60, 0xBD, 0x1E, 0x73, 0x92, 0x1E, 0xD4, 0x92, 0x03, 0x8F, 0x68, 0x48, 0x9E, 0x6D, 0x53, 0x1F, 0x5A, 0x7D, 0xE6]),
      Buffer.from([0x4C, 0xEA, 0x08, 0xF0, 0x3A, 0xA2, 0x7F, 0xF1, 0xBD, 0x61, 0x31, 0xC1, 0xC3, 0x79, 0xFF, 0x56, 0x04, 0x06, 0x49, 0x04]),
      Buffer.from([0x57, 0x74, 0x33, 0xE6, 0x6C, 0xFA, 0x46, 0xFA, 0x29, 0xB5, 0xF0, 0x26, 0x53, 0xEE, 0x07, 0x40, 0xE2, 0xC2, 0x56, 0xF4]),
      Buffer.from([0xAA, 0x78, 0xF9, 0x79, 0xBD, 0xA6, 0x8B, 0x04, 0x71, 0x07, 0x04, 0x63, 0xBF, 0x39, 0x8F, 0xD9, 0x96, 0xB0, 0x79, 0xB5]),
      Buffer.from([0x65, 0xF2, 0x36, 0xEC, 0xAD, 0xAB, 0x20, 0xA4, 0xD3, 0x20, 0x12, 0xEA, 0xD0, 0xB9, 0xB9, 0x14, 0x94, 0xA8, 0x8D, 0x8A]),
      Buffer.from([0xA8, 0xE7, 0x2C, 0xEC, 0x82, 0xA7, 0x63, 0x7A, 0x11, 0xBE, 0xA8, 0x49, 0xBA, 0xCB, 0x5C, 0x6A, 0xF0, 0xB1, 0x91, 0xBC]),
      Buffer.from([0x50, 0x0D, 0x72, 0xAE, 0xE8, 0x93, 0xE8, 0x3E, 0x55, 0x1F, 0x8F, 0x50, 0xEF, 0x9B, 0xA9, 0x49, 0xCD, 0x5B, 0x55, 0x94]),
      Buffer.from([0xBA, 0x3E, 0x65, 0x52, 0x88, 0xF2, 0x85, 0xBB, 0xBC, 0x83, 0x31, 0xBE, 0x98, 0xBF, 0x74, 0xA1, 0x40, 0xA9, 0xA4, 0xA4]),
      Buffer.from([0x66, 0xA0, 0x4C, 0xDC, 0xD1, 0xFD, 0x45, 0xA4, 0x06, 0x6A, 0xFC, 0xF9, 0x7E, 0x89, 0xCD, 0x4D, 0xFB, 0x90, 0xBD, 0x69]),
      Buffer.from([0xC5, 0x61, 0x49, 0x75, 0x11, 0xBB, 0xD4, 0x72, 0xE9, 0x7F, 0xD4, 0x40, 0x76, 0x39, 0x62, 0x92, 0x18, 0x74, 0xEE, 0x4E]),
      Buffer.from([0x11, 0x7E, 0x60, 0x65, 0x63, 0x55, 0x11, 0xA7, 0x69, 0x7C, 0xEF, 0x0A, 0x80, 0x83, 0x59, 0x65, 0x12, 0x27, 0xB5, 0xFF]),
      Buffer.from([0x09, 0x96, 0x7E, 0x27, 0x89, 0xDB, 0xB6, 0xF9, 0xA0, 0xEF, 0x4E, 0x18, 0xB6, 0xB3, 0xDD, 0xB8, 0xA9, 0x26, 0x84, 0x7F]),
      Buffer.from([0xEE, 0x00, 0x26, 0xDB, 0x8E, 0x04, 0x1D, 0x2C, 0x49, 0x3F, 0x96, 0x2E, 0x63, 0x4C, 0x50, 0x6E, 0xED, 0x43, 0x14, 0x86]),
      Buffer.from([0x0E, 0xCC, 0x47, 0x5D, 0x42, 0x4A, 0xBC, 0x2D, 0xBE, 0xFF, 0x23, 0x81, 0x59, 0x71, 0x16, 0x8A, 0x4D, 0xD4, 0x22, 0x0B]),
      Buffer.from([0xFC, 0xC2, 0xED, 0x2D, 0xDB, 0xC8, 0xC6, 0x32, 0x69, 0xB4, 0x0B, 0xFB, 0x23, 0xDA, 0x74, 0x52, 0x46, 0x32, 0x57, 0x37]),
      Buffer.from([0x6D, 0xE1, 0x55, 0xDC, 0x31, 0x4C, 0x0A, 0x4A, 0xDB, 0xC1, 0xE2, 0x9B, 0x79, 0x86, 0xB3, 0x58, 0xC3, 0xA9, 0x2B, 0xB2]),
      Buffer.from([0x73, 0x35, 0xEC, 0xB8, 0x47, 0xAD, 0x78, 0xBB, 0xE6, 0x04, 0xB9, 0xB0, 0xFB, 0x1C, 0x9A, 0xB8, 0xC2, 0xC8, 0xBB, 0xC9]),
      Buffer.from([0x86, 0xF8, 0x6C, 0xD8, 0xBF, 0x0A, 0xE9, 0x1D, 0xBE, 0xAD, 0xA7, 0x03, 0x19, 0x40, 0x43, 0xA3, 0xB0, 0x82, 0x6C, 0x8A]),
      Buffer.from([0x48, 0x3C, 0xCE, 0xD1, 0x93, 0x38, 0x36, 0xD6, 0x71, 0x69, 0x5F, 0xDE, 0x6D, 0x8C, 0x42, 0x4D, 0xED, 0x97, 0x9D, 0x41]),
      Buffer.from([0x34, 0x03, 0xAA, 0xC3, 0x70, 0x93, 0xE7, 0xAC, 0xDF, 0x73, 0xC0, 0x4C, 0xBA, 0x74, 0xD6, 0x22, 0xEF, 0x47, 0x44, 0x47]),
      Buffer.from([0x17, 0xC4, 0x7D, 0x7C, 0x5F, 0x60, 0x8A, 0xE4, 0xC3, 0x7C, 0x41, 0x40, 0xC9, 0x82, 0x17, 0x58, 0x7D, 0x34, 0x07, 0x4D]),
      Buffer.from([0x47, 0xDB, 0xED, 0x88, 0x96, 0xE6, 0x7B, 0xC5, 0xE5, 0xB7, 0xBF, 0x3B, 0xB9, 0x9D, 0x64, 0x95, 0xFF, 0x64, 0x4D, 0x2F]),
      Buffer.from([0xA2, 0xC7, 0x69, 0xE5, 0xEF, 0xBA, 0xA2, 0xD3, 0xD8, 0x0B, 0x2C, 0xDE, 0x77, 0xFF, 0x53, 0x23, 0xE1, 0xF7, 0xD6, 0x86]),
      Buffer.from([0x6D, 0xE1, 0x55, 0xDC, 0x31, 0x4C, 0x0A, 0x4A, 0xDB, 0xC1, 0xE2, 0x9B, 0x79, 0x86, 0xB3, 0x58, 0xC3, 0xA9, 0x2B, 0xB2]),
      Buffer.from([0x17, 0xC4, 0x7D, 0x7C, 0x5F, 0x60, 0x8A, 0xE4, 0xC3, 0x7C, 0x41, 0x40, 0xC9, 0x82, 0x17, 0x58, 0x7D, 0x34, 0x07, 0x4D]),
      Buffer.from([0xA8, 0xE7, 0x2C, 0xEC, 0x82, 0xA7, 0x63, 0x7A, 0x11, 0xBE, 0xA8, 0x49, 0xBA, 0xCB, 0x5C, 0x6A, 0xF0, 0xB1, 0x91, 0xBC]),
      Buffer.from([0xFC, 0xC2, 0xED, 0x2D, 0xDB, 0xC8, 0xC6, 0x32, 0x69, 0xB4, 0x0B, 0xFB, 0x23, 0xDA, 0x74, 0x52, 0x46, 0x32, 0x57, 0x37]),
      Buffer.from([0x09, 0x96, 0x7E, 0x27, 0x89, 0xDB, 0xB6, 0xF9, 0xA0, 0xEF, 0x4E, 0x18, 0xB6, 0xB3, 0xDD, 0xB8, 0xA9, 0x26, 0x84, 0x7F]),
      Buffer.from([0x17, 0xC4, 0x7D, 0x7C, 0x5F, 0x60, 0x8A, 0xE4, 0xC3, 0x7C, 0x41, 0x40, 0xC9, 0x82, 0x17, 0x58, 0x7D, 0x34, 0x07, 0x4D]),
      Buffer.from([0xA8, 0xE7, 0x2C, 0xEC, 0x82, 0xA7, 0x63, 0x7A, 0x11, 0xBE, 0xA8, 0x49, 0xBA, 0xCB, 0x5C, 0x6A, 0xF0, 0xB1, 0x91, 0xBC]),
      Buffer.from([0x11, 0x7E, 0x60, 0x65, 0x63, 0x55, 0x11, 0xA7, 0x69, 0x7C, 0xEF, 0x0A, 0x80, 0x83, 0x59, 0x65, 0x12, 0x27, 0xB5, 0xFF]),
      Buffer.from([0x09, 0x96, 0x7E, 0x27, 0x89, 0xDB, 0xB6, 0xF9, 0xA0, 0xEF, 0x4E, 0x18, 0xB6, 0xB3, 0xDD, 0xB8, 0xA9, 0x26, 0x84, 0x7F]),
      Buffer.from([0x65, 0xF2, 0x36, 0xEC, 0xAD, 0xAB, 0x20, 0xA4, 0xD3, 0x20, 0x12, 0xEA, 0xD0, 0xB9, 0xB9, 0x14, 0x94, 0xA8, 0x8D, 0x8A]),
      Buffer.from([0xC5, 0x61, 0x49, 0x75, 0x11, 0xBB, 0xD4, 0x72, 0xE9, 0x7F, 0xD4, 0x40, 0x76, 0x39, 0x62, 0x92, 0x18, 0x74, 0xEE, 0x4E]),
      Buffer.from([0xFC, 0xC2, 0xED, 0x2D, 0xDB, 0xC8, 0xC6, 0x32, 0x69, 0xB4, 0x0B, 0xFB, 0x23, 0xDA, 0x74, 0x52, 0x46, 0x32, 0x57, 0x37]),
      Buffer.from([0xAA, 0x78, 0xF9, 0x79, 0xBD, 0xA6, 0x8B, 0x04, 0x71, 0x07, 0x04, 0x63, 0xBF, 0x39, 0x8F, 0xD9, 0x96, 0xB0, 0x79, 0xB5]),
      Buffer.from([0x65, 0xF2, 0x36, 0xEC, 0xAD, 0xAB, 0x20, 0xA4, 0xD3, 0x20, 0x12, 0xEA, 0xD0, 0xB9, 0xB9, 0x14, 0x94, 0xA8, 0x8D, 0x8A]),
      Buffer.from([0x86, 0xF8, 0x6C, 0xD8, 0xBF, 0x0A, 0xE9, 0x1D, 0xBE, 0xAD, 0xA7, 0x03, 0x19, 0x40, 0x43, 0xA3, 0xB0, 0x82, 0x6C, 0x8A]),
      Buffer.from([0xFC, 0xC2, 0xED, 0x2D, 0xDB, 0xC8, 0xC6, 0x32, 0x69, 0xB4, 0x0B, 0xFB, 0x23, 0xDA, 0x74, 0x52, 0x46, 0x32, 0x57, 0x37]),
      Buffer.from([0xBA, 0x3E, 0x65, 0x52, 0x88, 0xF2, 0x85, 0xBB, 0xBC, 0x83, 0x31, 0xBE, 0x98, 0xBF, 0x74, 0xA1, 0x40, 0xA9, 0xA4, 0xA4]),
      Buffer.from([0x66, 0xA0, 0x4C, 0xDC, 0xD1, 0xFD, 0x45, 0xA4, 0x06, 0x6A, 0xFC, 0xF9, 0x7E, 0x89, 0xCD, 0x4D, 0xFB, 0x90, 0xBD, 0x69]),
      Buffer.from([0xC5, 0x61, 0x49, 0x75, 0x11, 0xBB, 0xD4, 0x72, 0xE9, 0x7F, 0xD4, 0x40, 0x76, 0x39, 0x62, 0x92, 0x18, 0x74, 0xEE, 0x4E]),
      Buffer.from([0x50, 0x0D, 0x72, 0xAE, 0xE8, 0x93, 0xE8, 0x3E, 0x55, 0x1F, 0x8F, 0x50, 0xEF, 0x9B, 0xA9, 0x49, 0xCD, 0x5B, 0x55, 0x94]),
      Buffer.from([0x09, 0x96, 0x7E, 0x27, 0x89, 0xDB, 0xB6, 0xF9, 0xA0, 0xEF, 0x4E, 0x18, 0xB6, 0xB3, 0xDD, 0xB8, 0xA9, 0x26, 0x84, 0x7F]),
      Buffer.from([0x17, 0xC4, 0x7D, 0x7C, 0x5F, 0x60, 0x8A, 0xE4, 0xC3, 0x7C, 0x41, 0x40, 0xC9, 0x82, 0x17, 0x58, 0x7D, 0x34, 0x07, 0x4D]),
      Buffer.from([0xA8, 0xE7, 0x2C, 0xEC, 0x82, 0xA7, 0x63, 0x7A, 0x11, 0xBE, 0xA8, 0x49, 0xBA, 0xCB, 0x5C, 0x6A, 0xF0, 0xB1, 0x91, 0xBC]),
      Buffer.from([0x11, 0x7E, 0x60, 0x65, 0x63, 0x55, 0x11, 0xA7, 0x69, 0x7C, 0xEF, 0x0A, 0x80, 0x83, 0x59, 0x65, 0x12, 0x27, 0xB5, 0xFF]),
      Buffer.from([0x09, 0x96, 0x7E, 0x27, 0x89, 0xDB, 0xB6, 0xF9, 0xA0, 0xEF, 0x4E, 0x18, 0xB6, 0xB3, 0xDD, 0xB8, 0xA9, 0x26, 0x84, 0x7F]),
      Buffer.from([0x66, 0xA0, 0x4C, 0xDC, 0xD1, 0xFD, 0x45, 0xA4, 0x06, 0x6A, 0xFC, 0xF9, 0x7E, 0x89, 0xCD, 0x4D, 0xFB, 0x90, 0xBD, 0x69]),
      Buffer.from([0x0E, 0xCC, 0x47, 0x5D, 0x42, 0x4A, 0xBC, 0x2D, 0xBE, 0xFF, 0x23, 0x81, 0x59, 0x71, 0x16, 0x8A, 0x4D, 0xD4, 0x22, 0x0B]),
      Buffer.from([0x50, 0x0D, 0x72, 0xAE, 0xE8, 0x93, 0xE8, 0x3E, 0x55, 0x1F, 0x8F, 0x50, 0xEF, 0x9B, 0xA9, 0x49, 0xCD, 0x5B, 0x55, 0x94])
    ];
  }

  // SHA1 hash for PC_LUT from CodeWalker
  private static getPC_LUT_HASH(): Buffer {
    return Buffer.from([0x88, 0xD3, 0x79, 0x3B, 0x8E, 0x7A, 0x6C, 0xAC, 0xAA, 0x8B, 0x89, 0x28, 0x97, 0xBE, 0x72, 0x8D, 0x9E, 0x7F, 0xBA, 0xD4]);
  }

  private static processMagicData(magicData: Buffer): Buffer {
    // Generate deterministic random bytes using JenkHash of PC_AES_KEY
    const seed = this.jenkHash(PC_AES_KEY);
    const rng = this.createSeededRandom(seed);

    const length = magicData.length;
    const rb1 = this.generateRandomBytes(rng, length);
    const rb2 = this.generateRandomBytes(rng, length);
    const rb3 = this.generateRandomBytes(rng, length);
    const rb4 = this.generateRandomBytes(rng, length);

    // Process the magic data: db[i] = (m[i] - rb1[i] - rb2[i] - rb3[i] - rb4[i]) & 0xFF
    const processed = Buffer.alloc(length);
    for (let i = 0; i < length; i++) {
      processed[i] = (magicData[i] - rb1[i] - rb2[i] - rb3[i] - rb4[i]) & 0xFF;
    }

    return processed;
  }

  private static jenkHash(data: Buffer): number {
    let h = 0;
    for (let i = 0; i < data.length; i++) {
      h += data[i];
      h += (h << 10);
      h ^= (h >> 6);
    }
    h += (h << 3);
    h ^= (h >> 11);
    h += (h << 15);
    return h >>> 0; // Ensure unsigned 32-bit
  }

  private static createSeededRandom(seed: number): { next(): number; nextBytes(buffer: Buffer): void } {
    // .NET Random implementation using Knuth's subtractive method
    const MSEED = 161803398;
    const MBIG = 2147483647; // Max int32

    const seedArray = new Array(56);
    let subtraction = (seed === -2147483648) ? 2147483647 : Math.abs(seed);
    let mj = MSEED - subtraction;
    seedArray[55] = mj;
    let mk = 1;

    for (let i = 1; i < 55; i++) {
      let ii = (21 * i) % 55;
      seedArray[ii] = mk;
      mk = mj - mk;
      if (mk < 0) mk += MBIG;
      mj = seedArray[ii];
    }

    for (let k = 1; k < 5; k++) {
      for (let i = 1; i < 56; i++) {
        seedArray[i] = (seedArray[i] - seedArray[1 + (i + 30) % 55] + MBIG) % MBIG;
      }
    }

    let inext = 0;
    let inextp = 21;

    return {
      next(): number {
        inext++;
        if (inext >= 56) inext = 1;
        inextp++;
        if (inextp >= 56) inextp = 1;

        let retVal = (seedArray[inext] - seedArray[inextp] + MBIG) % MBIG;
        if (retVal === MBIG) retVal--;

        seedArray[inext] = retVal;
        return retVal;
      },

      nextBytes(buffer: Buffer): void {
        for (let i = 0; i < buffer.length; i++) {
          buffer[i] = this.next() % 256;
        }
      }
    };
  }

  private static generateRandomBytes(rng: { nextBytes(buffer: Buffer): void }, length: number): Buffer {
    const bytes = Buffer.alloc(length);
    rng.nextBytes(bytes);
    return bytes;
  }

  private static decryptAESData(data: Buffer, key: Buffer): Buffer {
    // CodeWalker uses AES-256 but with a 16-byte key, so we need to extend it
    let extendedKey = key;
    if (key.length === 16) {
      // Extend 16-byte key to 32 bytes by repeating it
      extendedKey = Buffer.concat([key, key]);
    }

    const buffer = Buffer.from(data);
    const length = data.length - (data.length % 16); // Only decrypt complete 16-byte blocks

    for (let i = 0; i < length; i += 16) {
      const decipher = crypto.createDecipheriv('aes-256-ecb', extendedKey, null);
      decipher.setAutoPadding(false);

      const block = buffer.subarray(i, i + 16);
      const decryptedBlock = Buffer.concat([decipher.update(block), decipher.final()]);
      decryptedBlock.copy(buffer, i);
    }

    return buffer;
  }

  private static parseMagicData(data: Buffer): void {
    let offset = 0;

    // Parse NG keys (101 keys, 272 bytes each)
    const ngKeysSize = 101 * 272;
    this.PC_NG_KEYS = [];
    for (let i = 0; i < 101; i++) {
      const keyData = data.subarray(offset + i * 272, offset + (i + 1) * 272);
      this.PC_NG_KEYS.push(keyData);
    }
    offset += ngKeysSize;

    // Parse NG decrypt tables (17 rounds, 16 tables per round, 256 entries per table, 4 bytes per entry)
    const ngTablesSize = 17 * 16 * 256 * 4;
    this.PC_NG_DECRYPT_TABLES = [];
    for (let round = 0; round < 17; round++) {
      this.PC_NG_DECRYPT_TABLES[round] = [];
      for (let table = 0; table < 16; table++) {
        this.PC_NG_DECRYPT_TABLES[round][table] = [];
        for (let entry = 0; entry < 256; entry++) {
          const entryOffset = offset + (round * 16 * 256 * 4) + (table * 256 * 4) + (entry * 4);
          this.PC_NG_DECRYPT_TABLES[round][table][entry] = data.readUInt32LE(entryOffset);
        }
      }
    }
    offset += ngTablesSize;

    // Parse hash lookup table (256 bytes)
    this.PC_LUT = new Uint8Array(data.subarray(offset, offset + 256));
    offset += 256;
  }

  private static calculateHash(text: string): number {
    let result = 0;
    for (let i = 0; i < text.length; i++) {
      const temp = 1025 * (this.PC_LUT[text.charCodeAt(i)] + result);
      result = (temp >> 6) ^ temp;
    }
    return 32769 * ((9 * result >> 11) ^ (9 * result));
  }

  private static getNGKey(name: string, length: number): Buffer {
    const hash = this.calculateHash(name);
    const keyIdx = (hash + length + (101 - 40)) % 0x65;
    return this.PC_NG_KEYS[keyIdx];
  }

  private static decryptNGWithKey(data: Buffer, key: Buffer): Buffer {
    const decryptedData = Buffer.alloc(data.length);

    // Convert key to uint32 array
    const keyUints = new Uint32Array(key.length / 4);
    for (let i = 0; i < keyUints.length; i++) {
      keyUints[i] = key.readUInt32LE(i * 4);
    }

    // Decrypt each 16-byte block
    for (let blockIndex = 0; blockIndex < Math.floor(data.length / 16); blockIndex++) {
      const encryptedBlock = data.subarray(blockIndex * 16, (blockIndex + 1) * 16);
      const decryptedBlock = this.decryptNGBlock(encryptedBlock, keyUints);
      decryptedBlock.copy(decryptedData, blockIndex * 16);
    }

    // Handle remaining bytes (copy as-is)
    const remaining = data.length % 16;
    if (remaining > 0) {
      const lastBlockStart = Math.floor(data.length / 16) * 16;
      data.copy(decryptedData, lastBlockStart, lastBlockStart, lastBlockStart + remaining);
    }

    return decryptedData;
  }

  private static decryptNGBlock(data: Buffer, key: Uint32Array): Buffer {
    let buffer = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);

    // Prepare sub-keys
    const subKeys: Uint32Array[] = [];
    for (let i = 0; i < 17; i++) {
      subKeys[i] = new Uint32Array(4);
      subKeys[i][0] = key[4 * i + 0];
      subKeys[i][1] = key[4 * i + 1];
      subKeys[i][2] = key[4 * i + 2];
      subKeys[i][3] = key[4 * i + 3];
    }

    // Perform 17 rounds of decryption
    buffer = this.decryptNGRoundA(buffer, subKeys[0], this.PC_NG_DECRYPT_TABLES[0]);
    buffer = this.decryptNGRoundA(buffer, subKeys[1], this.PC_NG_DECRYPT_TABLES[1]);

    for (let k = 2; k <= 15; k++) {
      buffer = this.decryptNGRoundB(buffer, subKeys[k], this.PC_NG_DECRYPT_TABLES[k]);
    }

    buffer = this.decryptNGRoundA(buffer, subKeys[16], this.PC_NG_DECRYPT_TABLES[16]);

    return Buffer.from(buffer);
  }

  // Round 1, 2, 16
  private static decryptNGRoundA(data: Uint8Array, key: Uint32Array, table: number[][]): Uint8Array {
    const x1 = table[0][data[0]] ^ table[1][data[1]] ^ table[2][data[2]] ^ table[3][data[3]] ^ key[0];
    const x2 = table[4][data[4]] ^ table[5][data[5]] ^ table[6][data[6]] ^ table[7][data[7]] ^ key[1];
    const x3 = table[8][data[8]] ^ table[9][data[9]] ^ table[10][data[10]] ^ table[11][data[11]] ^ key[2];
    const x4 = table[12][data[12]] ^ table[13][data[13]] ^ table[14][data[14]] ^ table[15][data[15]] ^ key[3];

    const result = new Uint8Array(16);
    result[0] = (x1 >> 0) & 0xFF;
    result[1] = (x1 >> 8) & 0xFF;
    result[2] = (x1 >> 16) & 0xFF;
    result[3] = (x1 >> 24) & 0xFF;
    result[4] = (x2 >> 0) & 0xFF;
    result[5] = (x2 >> 8) & 0xFF;
    result[6] = (x2 >> 16) & 0xFF;
    result[7] = (x2 >> 24) & 0xFF;
    result[8] = (x3 >> 0) & 0xFF;
    result[9] = (x3 >> 8) & 0xFF;
    result[10] = (x3 >> 16) & 0xFF;
    result[11] = (x3 >> 24) & 0xFF;
    result[12] = (x4 >> 0) & 0xFF;
    result[13] = (x4 >> 8) & 0xFF;
    result[14] = (x4 >> 16) & 0xFF;
    result[15] = (x4 >> 24) & 0xFF;

    return result;
  }

  // Round 3-15
  private static decryptNGRoundB(data: Uint8Array, key: Uint32Array, table: number[][]): Uint8Array {
    const x1 = table[0][data[0]] ^ table[7][data[7]] ^ table[10][data[10]] ^ table[13][data[13]] ^ key[0];
    const x2 = table[1][data[1]] ^ table[4][data[4]] ^ table[11][data[11]] ^ table[14][data[14]] ^ key[1];
    const x3 = table[2][data[2]] ^ table[5][data[5]] ^ table[8][data[8]] ^ table[15][data[15]] ^ key[2];
    const x4 = table[3][data[3]] ^ table[6][data[6]] ^ table[9][data[9]] ^ table[12][data[12]] ^ key[3];

    const result = new Uint8Array(16);
    result[0] = (x1 >> 0) & 0xFF;
    result[1] = (x1 >> 8) & 0xFF;
    result[2] = (x1 >> 16) & 0xFF;
    result[3] = (x1 >> 24) & 0xFF;
    result[4] = (x2 >> 0) & 0xFF;
    result[5] = (x2 >> 8) & 0xFF;
    result[6] = (x2 >> 16) & 0xFF;
    result[7] = (x2 >> 24) & 0xFF;
    result[8] = (x3 >> 0) & 0xFF;
    result[9] = (x3 >> 8) & 0xFF;
    result[10] = (x3 >> 16) & 0xFF;
    result[11] = (x3 >> 24) & 0xFF;
    result[12] = (x4 >> 0) & 0xFF;
    result[13] = (x4 >> 8) & 0xFF;
    result[14] = (x4 >> 16) & 0xFF;
    result[15] = (x4 >> 24) & 0xFF;

    return result;
  }
}